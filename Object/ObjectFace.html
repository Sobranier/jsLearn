<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>面向对象</title>
</head>
<body>
<script>

    function Person() {
    }
    Person.prototype.name = "nio";
    Person.prototype.age = 12;
    Person.prototype.job = "Soft";
    Person.prototype.sayName = function() {
        console.log(this.name);
    };

    var person1 = new Person();
    var person2 = new Person();
    person1.sayName();
    person2.sayName();
    person2.name = "nihao";
    person2.sayName();

    console.log("==========");
    console.log(Person.prototype.isPrototypeOf(person1));
    console.log(Object.getPrototypeOf(person1));

    console.log("==========");
    console.log(person1.hasOwnProperty("name"));
    console.log(person2.hasOwnProperty("name"));
    console.log("name" in person1);
    console.log("name" in person2);

    function hasPrototypeProperty(object, name) {
        return !object.hasOwnProperty("name") && (name in object);
    }
    console.log(hasPrototypeProperty(person1, "name"));
    console.log(hasPrototypeProperty(person2, "name"));

    function People(){
    }

    People.prototype = {
        constructor: Person,
        name: "nio",
        job: "engine",
        sayName: function () {
            console.log(this.name);
        }
    };

    console.log("字面量形式完全重写prototype的时候的问题就是constructor不再指向Person,所以如果constructor很重要，需要显示设置");

    var people1 = new People;
    people1.sayName();

    console.log('注意Object、Array、String等原声类型也可以在构造函数的原型上定义方法');
    String.prototype.startsWith = function (text) {
        return this.indexOf(text) == 0;
    };

    var msg = "Hello World";
    console.log(msg.startsWith("Hello"));

</script>
</body>
</html>

